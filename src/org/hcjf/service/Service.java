package org.hcjf.service;

import org.hcjf.properties.SystemProperties;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.*;

/**
 * This abstract class contains all the implementations and
 * the interfaces that describe the behavior of the system service.
 * @author javaito
 * @email javaito@gmail.com
 */
public abstract class Service<C extends ServiceConsumer> {

    private final String serviceName;
    private final ThreadFactory serviceThreadFactory;
    private final ThreadPoolExecutor serviceExecutor;

    /**
     * Service constructor.
     * @param serviceName Name of the service, can't be null.
     * @throws NullPointerException If the name is null.
     */
    protected Service(String serviceName) {
        if(serviceName == null) {
            throw new NullPointerException("Service name can't be null");
        }

        this.serviceName = serviceName;
        this.serviceThreadFactory = createThreadFactory();
        this.serviceExecutor = (ThreadPoolExecutor) Executors.newCachedThreadPool(this.serviceThreadFactory);
        this.serviceExecutor.setMaximumPoolSize(SystemProperties.getInteger(SystemProperties.SERVICE_THREAD_POOL_MAX_SIZE));
        this.serviceExecutor.setKeepAliveTime(SystemProperties.getLong(SystemProperties.SERVICE_THREAD_POOL_KEEP_ALIVE_TIME), TimeUnit.SECONDS);
        init();
        SystemServices.instance.register(this);
    }

    /**
     *
     * @return
     */
    protected ThreadFactory createThreadFactory() {
        return new ThreadFactory() {

            @Override
            public Thread newThread(Runnable r) {
                return new ServiceThread(r);
            }

        };
    }

    /**
     * Return the internal thread pool executor of the service.
     * @return Thread pool executor.
     */
    private ThreadPoolExecutor getServiceExecutor() {
        return serviceExecutor;
    }

    /**
     *
     * @param runnable
     */
    protected final void fork(Runnable runnable) {
        fork(runnable, getServiceExecutor());
    }

    /**
     *
     * @param runnable
     * @param executor
     * @return
     */
    protected final void fork(Runnable runnable, ThreadPoolExecutor executor) {
        ServiceSession session = null;
        if(Thread.currentThread() instanceof ServiceThread) {
            session = ((ServiceThread) Thread.currentThread()).getSession();
        }
        executor.execute(new RunnableWrapper(runnable, session));
    }

    /**
     * Return the service name.
     * @return Service name.
     */
    public final String getServiceName() {
        return serviceName;
    }

    /**
     * This method will be called immediately after
     * of the execution of the service's constructor method
     */
    protected void init(){};

    /**
     * This method will be called immediately after the static
     * method 'shutdown' of the class has been called.
     */
    protected void shutdown(){};

    /**
     * This method register the consumer in the service.
     * @param consumer Object with the logic to consume the service.
     * @throws RuntimeException It contains exceptions generated by
     * the particular logic of each implementation.
     */
    public abstract void registerConsumer(C consumer);

    /**
     * This internal class contains all the services registered
     * in the system.
     */
    private static class SystemServices {

        private static final SystemServices instance;

        static {
            instance = new SystemServices();
        }

        private final Map<String, Service> services;

        /**
         * Constructor.
         */
        private SystemServices() {
            services = new HashMap<>();
        }

        /**
         * This method save the instance of the service in the internal
         * map indexed by the name of the service.
         * @param service Instance of the service.
         */
        private void register(Service service) {
            services.put(service.getServiceName(), service);
        }
    }

    /**
     *
     */
    private class RunnableWrapper implements Runnable {

        private final Runnable runnable;
        private final ServiceSession session;

        public RunnableWrapper(Runnable runnable, ServiceSession session) {
            this.runnable = runnable;
            if(session != null) {
                this.session = session;
            } else {
                this.session = ServiceSession.getGuestSession();
            }
        }

        @Override
        public void run() {
            if(!(Thread.currentThread() instanceof ServiceThread)) {
                throw new IllegalArgumentException("All the service executions must be over ServiceThread implementation");
            }

            try {
                session.startThread();
                ((ServiceThread) Thread.currentThread()).setSession(session);
                runnable.run();
            } finally {
                session.endThread();
                ((ServiceThread) Thread.currentThread()).setSession(null);
            }
        }
    }
}
